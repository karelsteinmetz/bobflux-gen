import * as g from '../src/cursorsGenerator';
import * as gb from '../src/generator';
import * as tsa from '../src/tsAnalyzer';
import * as log from '../src/logger';
import * as ts from 'typescript';
import * as fs from "fs";
import * as pathPlatformDependent from 'path';
const path = pathPlatformDependent.posix;

describe('cursorsGenerator', () => {
    let testCase: { do: () => Promise<string> };
    let logger = log.create(false, false, false, false);

    describe('auto-generated header', () => {
        beforeEach(() => {
            testCase = testCaseRun('IApplicationState', './stateTodos.ts', undefined, '0.5.3');
        });

        it('adds note', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`// 
// This source code was auto-generated by bobflux-gen, Version=0.5.3.
// Don't modify this file but re-generate it by bobflux-gen.
// Bobflux-gen - https://www.npmjs.com/package/bobflux-gen
//`);
                    done();
                });
        });
    });

    describe('custom types', () => {
        describe('internals', () => {
            beforeEach(() => {
                testCase = testCaseRun('IMapState', './stateWithType.ts');
            });

            it('generates cursor for field of custom type', (done) => {
                testCase
                    .do()
                    .then(text => {
                        expect(text).toContain(`
export const someMapCursor: bf.ICursor<s.MyMap> = {
    key: 'someMap'
};`);
                        done();
                    });
            });
        });

        describe('externals', () => {
            describe('namespace import', () => {
                beforeEach(() => {
                    testCase = testCaseRunRecurse('IApplicationState', './stateWithExternalType.ts', 'stateWithExternalType');
                });

                it('generates import for declared file', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
import * as e from './stateWithType';
`);
                            done();
                        });
                });

                it('generates cursor for field of declared type', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const someExternalMapCursor: bf.ICursor<e.MyMap> = {
    key: 'someExternalMap'
};`);
                            done();
                        });
                });

                it('generates cursor for field of custom type in IComponentState', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const externalStateSomeMapCursor: bf.ICursor<e.MyMap> = {
    key: 'externalState.someMap'
};`);
                            done();
                        });
                });

            });

            describe('direct type import', () => {
                beforeEach(() => {
                    testCase = testCaseRunRecurse('IApplicationState', './stateWithExternalTypeAndDirectImport.ts', 'stateWithExternalType');
                });

                it('generates import for declared file', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
import * as stateWithType from './stateWithType';
`);
                            done();
                        });
                });

                it('generates cursor for field of declared type', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const someExternalMapCursor: bf.ICursor<stateWithType.MyMap> = {
    key: 'someExternalMap'
};`);
                            done();
                        });
                });

                it('generates cursor for field of custom type in IComponentState', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const externalStateSomeMapCursor: bf.ICursor<stateWithType.MyMap> = {
    key: 'externalState.someMap'
};`);
                            done();
                        });
                });
            });

            describe('direct type import with rename', () => {
                beforeEach(() => {
                    testCase = testCaseRunRecurse('IApplicationState', './stateWithExternalTypeAndDirectRenamedImport.ts', 'stateWithExternalType');
                });

                it('generates import for declared file', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
import * as stateWithType from './stateWithType';
`);
                            done();
                        });
                });

                it('generates cursor for field of declared type', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const someExternalMapCursor: bf.ICursor<stateWithType.MyMap> = {
    key: 'someExternalMap'
};`);
                            done();
                        });
                });

                it('generates cursor for field of custom type in IComponentState', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const externalStateSomeMapCursor: bf.ICursor<stateWithType.MyMap> = {
    key: 'externalState.someMap'
};`);
                            done();
                        });
                });
            });
        });
    });

    describe('enums', () => {
        beforeEach(() => {
            testCase = testCaseRun('IApplicationState', './stateWithEnum.ts');
        });

        it('generates cursor for field of enum type', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const someEnumCursor: bf.ICursor<s.SomeEnum> = {
    key: 'someEnum'
};
`);
                    done();
                });
        });
    });

    describe('state todos', () => {
        beforeEach(() => {
            testCase = testCaseRun('IApplicationState', './stateTodos.ts');
        });

        it('generates cursors for todos', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`import * as s from './stateTodos';
import * as f from './flux';

export * from './stateTodos';

export const rootKey = f.rootCursor.key;

export const rootCursor: f.ICursor<s.IApplicationState> = f.rootCursor;

export default rootCursor;

export const todoSectionCursor: f.ICursor<s.ITodosState> = {
    key: 'todoSection'
};

export const todoSectionEditedTodoCursor: f.ICursor<s.ITodo> = {
    key: 'todoSection.editedTodo'
};

export const todoSectionTodosCursor: f.ICursor<s.ITodo[]> = {
    key: 'todoSection.todos'
};

export const todoSectionEditedTodoIdCursor: f.ICursor<number> = {
    key: 'todoSection.editedTodo.id'
};

export const todoSectionEditedTodoIsDoneCursor: f.ICursor<boolean> = {
    key: 'todoSection.editedTodo.isDone'
};

export const todoSectionEditedTodoNameCursor: f.ICursor<string> = {
    key: 'todoSection.editedTodo.name'
};
`);
                    done();
                })
                .catch(e => { expect(e).toBeUndefined(); done(); });
        });
    });

    describe('state with map', () => {
        beforeEach(() => {
            testCase = testCaseRun('IApplicationState', './stateWithMap.ts');
        });

        it('generates cursors for appState which has simple map fields', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const rootKey = bf.rootCursor.key;

export const rootCursor: bf.ICursor<s.IApplicationState> = bf.rootCursor;

export default rootCursor;

export const stringCountsCursor: bf.ICursor<{ [s: string]: number }> = {
    key: 'stringCounts'
};
`);
                    done();
                });
        });

        it('generates cursors for appState which has map fields with interface', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const nestedStatesCursor: bf.ICursor<{ [s: string]: s.INestedState }> = {
    key: 'nestedStates'
};
`);
                    done();
                });
        });

        it('generates cursors for appState which has map fields with generic interface', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const genericNestedStatesCursor: bf.ICursor<{ [s: string]: s.IGenericNestedState<s.INestedState> }> = {
    key: 'genericNestedStates'
};
`);
                    done();
                });
        });
    });

    describe('state with array', () => {
        beforeEach(() => {
            testCase = testCaseRun('IApplicationState', './stateWithArray.ts');
        });

        it('generates cursors for appState which has array fields', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const stringsCursor: bf.ICursor<string[]> = {
    key: 'strings'
};

export const numbersCursor: bf.ICursor<s.INumber[]> = {
    key: 'numbers'
};
`);
                    done();
                });
        });
    });

    describe('state with external state', () => {
        describe('with rootStateKey', () => {
            describe('file stateWithInner', () => {
                beforeEach(() => {
                    testCase = testCaseRunRecurse('IApplicationState', './stateWithInner.ts', 'stateWithInner', 'root.subroot');
                });

                it('contains rootKey', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const rootKey = 'root.subroot';
`);
                            done();
                        });
                });

                it('contains correct import prefix of state fields', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const rootCursor: f.ICursor<s.IApplicationState> = {
    key: rootKey
};

export default rootCursor;
`);
                            done();
                        });
                });

                it('contains correct import prefix of external nested state fields', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const innerStateCursor: f.ICursor<is.IInnerState> = {
    key: rootKey + '.innerState'
};
`);
                            done();
                        });
                });
            })

            describe('file stateWithExternalState', () => {
                beforeEach(() => {
                    testCase = testCaseRun('IApplicationState', 'stateWithExternalState.ts', 'root.subroot');
                });

                it('generates cursors for appState fields', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const rootKey = 'root.subroot';
`);
                            done();
                        });
                });
            });
        });

        describe('without rootStateKey', () => {
            describe('file stateWithInner', () => {
                beforeEach(() => {
                    testCase = testCaseRunRecurse('IApplicationState', './stateWithInner.ts', 'stateWithInner');
                });

                it('contains import of state file', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`import * as s from './stateWithInner';`);
                            done();
                        });
                });

                it('contains import of external nested state file', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`import * as is from './inner/innerState';`);
                            done();
                        });
                });

                it('contains import of external nested type file', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`import * as it from './inner/innerType';`);
                            done();
                        });
                });

                it('contains imports of external recursively nested files', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`import * as sms from './inner/some/someState';`);
                            expect(text).toContain(`import * as smt from './inner/some/someType';`);
                            done();
                        });
                });

                it('contains correct import prefix of state fields', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const rootCursor: f.ICursor<s.IApplicationState> = f.rootCursor;
`);
                            done();
                        });
                });

                it('contains correct import prefix of external nested state fields', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const innerStateCursor: f.ICursor<is.IInnerState> = {
    key: 'innerState'
};
`);
                            expect(text).toContain(`
export const innerTypeCursor: f.ICursor<it.IInnerState> = {
    key: 'innerType'
};
`);
                            done();
                        });
                });
                it('contains correct import prefix of external recursively nested state fields', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const innerTypeSomeStateCursor: f.ICursor<sms.ISomeState> = {
    key: 'innerType.someState'
};
`);
                            expect(text).toContain(`
export const innerTypeSomeTypeCursor: f.ICursor<smt.ISomeState> = {
    key: 'innerType.someType'
};
`);
                            expect(text).toContain(`
export const innerTypeSomeTypeSomeFieldCursor: f.ICursor<string> = {
    key: 'innerType.someType.someField'
};
`);
                            done();
                        });
                });
            });

            describe('file stateWithExternalState', () => {
                beforeEach(() => {
                    testCase = testCaseRunRecurse('IApplicationState', 'stateWithExternalState.ts', 'stateWithExternalState')
                });

                it('imports related state', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text.split('\n')[6]).toBe(`import * as s from './stateWithExternalState';`);
                            done();
                        })
                });

                it('imports bobflux as node module', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text.split('\n')[7]).toBe(`import * as bf from 'bobflux';`);
                            done();
                        });
                });

                it('imports external state', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text.split('\n')[8]).toBe(`import * as ns from './stateWithNestedState';`);
                            done();
                        });
                });

                it('generates rootCursor', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`export const rootKey = bf.rootCursor.key;`);
                            done();
                        });
                });

                it('generates cursors for appState fields from stateWithExternalState', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`export const stringValueCursor: bf.ICursor<string> = {
    key: 'stringValue'
};

export const nestedComponentStateCursor: bf.ICursor<ns.INestedState> = {
    key: 'nestedComponentState'
};
`);
                            done();
                        });
                });

                it('generates cursors for appState fields from stateWithNestedState', (done) => {
                    testCase
                        .do()
                        .then(text => {
                            expect(text).toContain(`
export const nestedComponentStateNumberValueCursor: bf.ICursor<number> = {
    key: 'nestedComponentState.numberValue'
};
`);
                            done();
                        });
                });
            });
        });
    })

    describe('stateWithNestedState', () => {
        beforeEach(() => {
            testCase = testCaseRun('IApplicationState', './stateWithNestedState.ts')
        });

        it('imports bobflux as node module', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text.split('\n')[7]).toBe(`import * as bf from 'bobflux';`);
                    done();
                });
        });

        it('imports related state', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`import * as s from './stateWithNestedState';`);
                    done();
                });
        });

        it('generates main rootCursor and typed it', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`export const rootCursor: bf.ICursor<s.IApplicationState> = bf.rootCursor;`);
                    done();
                });
        });

        it('generates cursor for string fields in app state', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const stringValueCursor: bf.ICursor<string> = {
    key: 'stringValue'
};
`);
                    done();
                });
        });

        it('generates cursor for nested state in app state', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const stringValueCursor: bf.ICursor<string> = {
    key: 'stringValue'
};
`);
                    done();
                });
        });

        it('generates cursor for secondNested field with parent cursor prefix', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const secondNestedStringValueCursor: bf.ICursor<string> = {
    key: 'secondNested.stringValue'
};
`);
                    done();
                });
        });

        it('generates cursors for appState fields', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const stringValueCursor: bf.ICursor<string> = {
    key: 'stringValue'
};

export const nestedCursor: bf.ICursor<s.INestedState> = {
    key: 'nested'
};

export const secondNestedCursor: bf.ICursor<s.ISecondNestedState> = {
    key: 'secondNested'
};

export const nestedNumberValueCursor: bf.ICursor<number> = {
    key: 'nested.numberValue'
};

export const secondNestedStringValueCursor: bf.ICursor<string> = {
    key: 'secondNested.stringValue'
};
`);
                    done();
                });
        });
    });

    describe('state with base types', () => {
        beforeEach(() => {
            testCase = testCaseRun('IApplicationState', './stateWithBaseTypes.ts');
        });

        it('imports bobflux as node module', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text.split('\n')[7]).toBe(`import * as bf from 'bobflux';`);
                    done();
                });
        });

        it('imports related state', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text.split('\n')[6]).toBe(`import * as s from './stateWithBaseTypes';`);
                    done();
                });
        });

        it('generates main rootCursor and typed it', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`export const rootCursor: bf.ICursor<s.IApplicationState> = bf.rootCursor;`);
                    done();
                });
        });

        it('generates state with base types', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`import * as s from './stateWithBaseTypes';
import * as bf from 'bobflux';

export * from './stateWithBaseTypes';

export const rootKey = bf.rootCursor.key;

export const rootCursor: bf.ICursor<s.IApplicationState> = bf.rootCursor;

export default rootCursor;

export const stringValueCursor: bf.ICursor<string> = {
    key: 'stringValue'
};

export const numberValueCursor: bf.ICursor<number> = {
    key: 'numberValue'
};
`);
                    done();
                });

        });
    });

    describe('class with generics', () => {
        beforeEach(() => {
            testCase = testCaseRun('ApplicationState', './classWithGenericType.ts');
        });

        it('generates cursor for generic type', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const genericCursor: bf.ICursor<s.GenericState<string>> = {
    key: 'generic'
};
`);
                    done();
                });

        });
    });

    describe('state with union type', () => {
        beforeEach(() => {
            testCase = testCaseRun('IApplicationState', './stateWithUnionType.ts');
        });

        it('generates cursor for union type', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const stringOrNullCursor: bf.ICursor<string | null> = {
    key: 'stringOrNull'
};
`);
                    done();
                });
        });

        it('generates cursor for optional type', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const optionalStringCursor: bf.ICursor<string | undefined> = {
    key: 'optionalString',
    isUndefinable: true
};
`);
                    done();
                });
        });

        it('does not add extra undefined option if it is already there', (done) => {
            testCase
                .do()
                .then(text => {
                    expect(text).toContain(`
export const doubleOptionalStringCursor: bf.ICursor<string | undefined> = {
    key: 'doubleOptionalString',
    isUndefinable: true
};
`);
                    done();
                });
        });
    });

    it('generates state with parent cursor key', (done) => {
        testCaseRun('IApplicationState', './stateWithBaseTypes.ts', 'parentCursorKey')
            .do()
            .then(text => {
                expect(text).toContain(`
export const rootKey = 'parentCursorKey';

export const rootCursor: bf.ICursor<s.IApplicationState> = {
    key: rootKey
};

export default rootCursor;
`);
                done();
            });

    });

    describe('createCursorFilePath', () => {
        it('creates file path for cursors from state file path', () => {
            expect(g.createCursorsFilePath('c:/app/state.ts'))
                .toBe('c:/app/state.cursors.ts');
        });
    });

    describe('reExported type', () => {
        beforeEach(() => {
            testCase = testCaseRunRecurse(
                'IApplicationState',
                './stateWithExternalTypeReExported.ts',
                'stateWithExternalType'
            );
        });

        it('generate curosr with correct state chain for reexported InnerState', done => {
            testCase.do().then(text => {
                expect(text).toContain(`
export const externalTypeReexportedCursor: f.ICursor<ExportType.SomeOtherType.IInnerState> = {
    key: 'externalTypeReexported'
};`);
                done();
            });
        });
    });

    function aProject(appStateName: string, appFilePath: string, writeFileCallback: (filename: string, b: Buffer) => void, version: string = 'AVersion'): gb.IGenerationProject {
        return {
            version: version,
            dir: __dirname,
            appStateName: appStateName,
            appSourcesDirectory: path.join(__dirname, 'resources'),
            appStateFileName: path.basename(appFilePath),
            tsOptions: { module: ts.ModuleKind.CommonJS, target: ts.ScriptTarget.ES5, skipDefaultLibCheck: true },
            writeFileCallback: writeFileCallback
        }
    }

    function testCaseRun(appStateName: string, appFilePath: string, rootStateKey?: string, version?: string) {
        let returned = false;
        return {
            do: () => new Promise<string>((f, r) => {
                g.default(aProject(appStateName, appFilePath, (filename: string, b: Buffer) => {
                    f(b.toString('utf8'));
                    returned = true;
                }, version), tsa.create(logger), logger, rootStateKey).run().then(() => !returned && f(''));
            })
        };
    }

    function testCaseRunRecurse(appStateName: string, appFilePath: string, expectedFilename: string, rootStateKey?: string) {
        let returned = false;
        return {
            do: () => new Promise<string>((f, r) => {
                g.default(aProject(appStateName, appFilePath, (filename: string, b: Buffer) => {
                    if (filename.indexOf(expectedFilename) !== -1) {
                        f(b.toString('utf8'));
                        returned = true;
                    }
                }), tsa.create(logger), logger, rootStateKey).runRecurse().then(() => !returned && f(''));
            })
        };
    }
});